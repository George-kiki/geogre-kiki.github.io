<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content>
    <meta name="author" content="George-kiki">
    <!-- Open Graph Data -->
    <meta property="og:title" content="前端模块化">
    <meta property="og:description" content>
    <meta property="og:site_name" content="George-kiki">
    <meta property="og:type" content="article">
    <meta property="og:image" content="https://github.com/George-kiki">
    
        <link rel="alternate" href="/atom.xml" title="George-kiki" type="application/atom+xml">
    
    
        <link rel="icon" href="/favicon.png">
    

    <!-- Site Title -->
    <title>George-kiki</title>

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <!-- Custom CSS -->
    
    <link rel="stylesheet" href="/css/style.light.css">

    <!-- Google Analytics -->
    

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//cdn.dode.top/Hitalk.min.js"></script>
</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/animation_sea_bg.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">前端模块化</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/George-kiki">
                  
                  Github
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
    <div class="container typo">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-info text-muted">
                    
                        <!-- Author -->
                        <span class="author info">By George-kiki</span>
                    
                    <!-- Date -->
                    <span class="date-time info">On
            <span class="date">2019-09-03</span>
            <span class="time">14:30:41</span>
          </span>
                    
                        <!--  Categories  -->
                        <span class="categories info">Under 

<a href="/categories/coding/">coding</a>
</span>
                    
                </div>
                <!-- Tags -->
                
                    <div class="post-tags text-muted">
                        Tags: 

<a class="tag" href="/tags/JavaScript/">#JavaScript</a> <a class="tag" href="/tags/Module/">#Module</a> <a class="tag" href="/tags/ES6/">#ES6</a>


                    </div>
                
                <!-- Post Main Content -->
                <div class="post-content">
                    <h3 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化?"></a>什么是模块化?</h3><p>将一个复杂的程序按照规定(规范)封装成相应的功能块(文件),并进行组合。<br>块内部的数据与实现是私有的,只是向外暴露一些接口(方法)与外部其他模块通信。</p>
<h4 id="说到模块化首先想到的就是script标签的插入"><a href="#说到模块化首先想到的就是script标签的插入" class="headerlink" title="说到模块化首先想到的就是script标签的插入"></a>说到模块化首先想到的就是script标签的插入</h4><p>script标签的插入很方便,当个多个script标签插入时,<br>容易造成变量污染,还得注意script标签的顺序,使代码不易维护。</p>
<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>NodeJS是CommonJS规范的主要实践者,它有四个重要的模块化实现提供支持:<br>module、exports、require、global。用module.exports定义当前模块对外输出的接口(不推荐直接使用exports),<br>用require加载模块。</p>
<h3 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h3><p>Node.js模块导出的关键字，导出的是对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义模块*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseModule</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*对外输出*/</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  BaseModule: <span class="keyword">new</span> BaseModule</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><p>Node.js遵循CommonJS规范,使用require关键字来加载模块。<br>require重复引入不会造成重复,当引入第一次时,引入的模块就会被提取到缓存副本中,每个模块在缓存中只存在一个实例。<br>require加载模块是同步操作,CommonJS规范一般用于服务端，同步的，因为在服务器端所有文件都存储在本地的硬盘上，传输速率快而且稳定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*加载定义模块*/</span></span><br><span class="line"><span class="keyword">let</span> BaseModule = <span class="built_in">require</span>(<span class="string">'BaseModule'</span>)</span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  name: <span class="string">'George'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> app = BaseModule(data)</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CommonJS用同步的方式加载模块。在服务器端，模块文件都存在本地磁盘，读取都速度非常的快，所以同步操作是没有问题的。<br>但是在浏览器端，由于网络都原因，异步加载模块是更合理的操作。</p>
<h3 id="AMD和CMD"><a href="#AMD和CMD" class="headerlink" title="AMD和CMD"></a>AMD和CMD</h3><p>说完服务器端肯定少不了浏览器端，浏览器端除了我们通常用都script标签引入，还有我们熟悉的AMD和CMD这两种解决模块化都方案。</p>
<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>AMD规范采用异步的方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都会定义在一个回调函数中。等页面加载完成后才执行回调函数。<br>这里用requireJS实现AMD规范的模块化<br>这里引入的是一个CDN包，data-main是基础配置文件，所有引入的模块都需要在这个文件定义。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/require.js/2.3.6/require.js"</span> <span class="attr">data-main</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* baseUrl 需要引入的模块所在文件</span></span><br><span class="line"><span class="comment">* paths 需要引入都模块文件名以及别名都设置</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  baseUrl: <span class="string">'lib'</span>,</span><br><span class="line">  paths: &#123;</span><br><span class="line">    <span class="string">'compile'</span>: <span class="string">'compile'</span>,</span><br><span class="line">    <span class="string">'watcher'</span>: <span class="string">'watcher'</span>,</span><br><span class="line">    <span class="string">'observer'</span>: <span class="string">'observer'</span>,</span><br><span class="line">    <span class="string">'vm'</span>: <span class="string">'vm'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* require第一个参数是数组，数组的每一项是需要引入模块的别名</span></span><br><span class="line"><span class="comment">* 第二个参数是回调函数，当页面加载完毕就执行该回调函数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'compile'</span>, <span class="string">'watcher'</span>, <span class="string">'vm'</span>, <span class="string">'obserbser'</span>],<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vm (&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      text: <span class="string">'Hello World'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD是另一种模块化的方案，它与AMD很类似，不同点在于：AMD推崇依赖前置、提前执行<br>CMD推崇依赖就近、延迟执行。此规范其实是在SeaJS推广的过程中产生的。<br>引入SeaJS的CND包和配置模块文件main.js</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/seajs/3.0.3/sea.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sciprt</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">sciprt</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.js中定义导出的模块*/</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./vm.js'</span>)</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./compile.js'</span>)</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./observer.js'</span>)</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./watcher.js'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> &gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">/*在加载模块的回调函数中可以做一些操作，比如初始化数据*/</span></span></span><br><span class="line"><span class="javascript">    seajs.use(<span class="string">'./main'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> app = <span class="keyword">new</span> Vm (&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">'#app'</span>,</span></span><br><span class="line">      data: &#123;</span><br><span class="line"><span class="javascript">        message: <span class="string">'Hello World'</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>ES6在JS语言标准的层面上，实现了模块功能，成为浏览器和服务器端的通用解决方案。<br>其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外导出，import命令用于导入规定模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义模块导出add.js*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于ADM的引用写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*引入上面对外导出的模块*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">'./add.js'</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>ES6的模块不是对象，import命令会被JavaScript引擎静态分析，在编译时引入代码，而不是运行时加载，所以无法实现条件加载。</p>
<h4 id="浏览器module的使用"><a href="#浏览器module的使用" class="headerlink" title="浏览器module的使用"></a>浏览器module的使用</h4><p>浏览器对于带有type=”module”的script，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了script标签的defer属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./add.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6Module和CommonJS的区别"><a href="#ES6Module和CommonJS的区别" class="headerlink" title="ES6Module和CommonJS的区别"></a>ES6Module和CommonJS的区别</h3><p>CommonJS模块输出是值的拷贝,一旦输出了这个值,内部模块改变也不会影响到这个值。  </p>
<p>ES6模块的运行机制和CommonJS不同,JS引擎对脚本静态分析时,遇到模块加载命令import,就会生成一个只读命令,当脚本执行时,再根据这个只读命令,去加载相应的模块的值,模块内部发生变化,值也会发生变,因此ES6模块引入也被称为动态引入,模块里的变量不会缓存而是绑定其所在的模块。</p>
<h3 id="CommonJS是运行时加载，ES6Module是编译时输出接口"><a href="#CommonJS是运行时加载，ES6Module是编译时输出接口" class="headerlink" title="CommonJS是运行时加载，ES6Module是编译时输出接口"></a>CommonJS是运行时加载，ES6Module是编译时输出接口</h3><p>运行时加载：CommonJS模块是对象的形式，在输出时加载整个模块，生成对象，然后再从这个对象上面读取方法。<br>编译时加载：ES6Module不是对象，而是通过export命令导出某个特定的代码块，import采用静态命令的形式，import时可以指定加载某个输出值，而不是整个模块。  </p>
<h5 id="CommonJS对象在脚本运行完后生成"><a href="#CommonJS对象在脚本运行完后生成" class="headerlink" title="CommonJS对象在脚本运行完后生成"></a>CommonJS对象在脚本运行完后生成</h5><h5 id="ES6Module是它对外的接口定义，在代码编译阶段完成"><a href="#ES6Module是它对外的接口定义，在代码编译阶段完成" class="headerlink" title="ES6Module是它对外的接口定义，在代码编译阶段完成"></a>ES6Module是它对外的接口定义，在代码编译阶段完成</h5>
                </div>
            </div>
        </div>
    </div>
    <div id="comment"></div>
</article>
<script>
  new Hitalk({
    el: '#comment' ,
    appId: 'VnAjBQDKjiiQGPcIkYu4TGDm-gzGzoHsz',
    appKey: '1T0fJve6IS0KxGXnCXg6luIl',
    placeholder: '快来评论吧',
    path:window.location.pathname,
    avatar:'mm'
  });
</script>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          萌萌哒博客 <a target="_blank" href="https://github.com/George-kiki">George-kiki</a>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

